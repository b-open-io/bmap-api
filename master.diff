diff --git a/.cursorrules b/.cursorrules
index 4b9849a..837d5f8 100644
--- a/.cursorrules
+++ b/.cursorrules
@@ -53,7 +53,9 @@ Core Files:
 - **`chart.ts`**: Chart generation using Chart.js/canvas
 - **`bap.ts`**: BAP identity management
 - **`actions.ts`**: Transaction saving and database operations
-- **`social.ts`**: Social feature endpoints (friends, likes, identities)
+- **`social/routes.ts`**: Social feature endpoints (friends, likes, identities)
+- **`social/queries/`**: Social feature query functions
+- **`social/swagger/`**: Social feature OpenAPI definitions
 - **`types.ts`**: Shared TypeScript types and interfaces
 - **`bmap.ts`**: BMAP transaction normalization
 
@@ -245,4 +247,26 @@ return {
   displayName: data.name || "Unknown",
   icon: data.icon || null           // Convert undefined to null
 };
+```
+
+# Making Careful Edits
+
+When editing files, follow these strict rules:
+1. ALWAYS read the file first to understand exact context and line numbers
+2. Use precise line targeting with tools like `sed`
+3. Make minimal changes - one line at a time
+4. Verify after each change
+5. When using `sed`, use exact line numbers and patterns
+6. Include comments in the edit to help the apply model understand the scope
+
+Example of careful editing:
+```bash
+# 1. First read to confirm exact line and content
+sed -n '7p' file.txt
+
+# 2. Make targeted change with exact line number
+sed -i '' '7s/^old/new/' file.txt
+
+# 3. Verify the change
+sed -n '7p' file.txt
 ```
\ No newline at end of file
diff --git a/bap.ts b/bap.ts
index cb87b04..e01f9ff 100644
--- a/bap.ts
+++ b/bap.ts
@@ -4,34 +4,20 @@ import { normalize } from './bmap.js';
 import { type CacheValue, readFromRedis, saveToRedis } from './cache.js';
 const { uniq, uniqBy } = _;
 
-interface BapAddress {
-  address: string;
-  txId: string;
-  block?: number;
-}
-
-export interface BapIdentityObject {
-  alternateName?: string;
-  name?: string;
-  description?: string;
-  url?: string;
-  image?: string;
-  [key: string]: unknown;
-}
-
 export type BapIdentity = {
+  idKey: string;
   rootAddress: string;
   currentAddress: string;
-  addresses: BapAddress[];
-  identity: string | BapIdentityObject;
+  addresses: {
+    address: string;
+    txId: string;
+    block: number | undefined;
+  }[];
+  identity: string;
   identityTxId: string;
-  idKey: string;
   block: number;
   timestamp: number;
   valid: boolean;
-  paymail?: string;
-  displayName?: string;
-  icon?: string;
 };
 
 const bapApiUrl = 'https://api.sigmaidentity.com/v1/';
diff --git a/cache.ts b/cache.ts
index b66717e..e50b223 100644
--- a/cache.ts
+++ b/cache.ts
@@ -5,15 +5,11 @@ import type { BapIdentity } from './bap.js';
 import type { TimeSeriesData } from './chart.js';
 import { getCurrentBlockHeight } from './db.js';
 
+import type { DMResponse } from './queries/messages.js';
 // Import interfaces from social.ts
-import type {
-  CacheListResponse,
-  ChannelInfo,
-  ChannelMessage,
-  DMResponse,
-  LikeInfo,
-  Reactions,
-} from './social.js';
+import type { ChannelInfo } from './social/swagger/channels.js';
+import type { LikeResponse, Reactions } from './social/swagger/likes.js';
+import type { ChannelMessage } from './social/swagger/messages.js';
 
 const client = redis.createClient({
   url: process.env.REDIS_PRIVATE_URL,
@@ -50,7 +46,7 @@ export type CacheValue =
   | { type: 'tx'; value: BmapTx }
   | { type: 'count'; value: Record<string, number>[] }
   | { type: 'signer'; value: BapIdentity }
-  | { type: 'likes'; value: LikeInfo }
+  | { type: 'likes'; value: LikeResponse }
   | { type: 'channels'; value: ChannelInfo[] }
   | { type: 'messages'; value: ChannelMessage | DMResponse }
   | { type: 'blockHeight'; value: number }
@@ -58,7 +54,7 @@ export type CacheValue =
   | { type: 'chart'; value: ChartCacheData }
   | { type: 'timeSeriesData'; value: TimeSeriesData }
   | { type: 'reactions'; value: Reactions }
-  | { type: 'identities'; value: CacheListResponse };
+  | { type: 'identities'; value: BapIdentity[] };
 
 export async function saveToRedis<T extends CacheValue>(key: string, value: T): Promise<void> {
   await client.set(key, JSON.stringify(value));
diff --git a/index.ts b/index.ts
index ddf96fc..6db242f 100644
--- a/index.ts
+++ b/index.ts
@@ -31,7 +31,7 @@ import { Timeframe } from './types.js';
 
 import type { ChangeStream } from 'mongodb';
 import { bitcoinSchemaCollections, htmxRoutes } from './htmx.js';
-import { socialRoutes } from './social.js';
+import { socialRoutes } from './social/routes.js';
 
 dotenv.config();
 
diff --git a/queries/messages.ts b/queries/messages.ts
new file mode 100644
index 0000000..9f4e535
--- /dev/null
+++ b/queries/messages.ts
@@ -0,0 +1,171 @@
+import type { BmapTx } from 'bmapjs';
+import type { ChangeStream } from 'mongodb';
+import type { BapIdentity } from '../bap.js';
+import { getBAPIdByAddress } from '../bap.js';
+import { getDbo } from '../db.js';
+
+interface MessageQueryParams {
+  bapId: string;
+  bapAddress: string;
+  targetBapId?: string;
+  targetAddress?: string;
+}
+
+export interface DMResponse {
+  bapID: string;
+  page: number;
+  limit: number;
+  count: number;
+  results: BmapTx[];
+  signers: BapIdentity[];
+}
+
+interface DirectMessagesParams {
+  bapId: string;
+  targetBapId?: string | null;
+  page: number;
+  limit: number;
+}
+
+/**
+ * Fetches direct messages between two BAP IDs with pagination
+ */
+export async function getDirectMessages({
+  bapId,
+  targetBapId = null,
+  page = 1,
+  limit = 100,
+}: DirectMessagesParams): Promise<DMResponse> {
+  const dbo = await getDbo();
+  const skip = (page - 1) * limit;
+
+  const query = targetBapId
+    ? {
+        $or: [
+          { 'MAP.bapID': bapId, 'MAP.targetBapID': targetBapId },
+          { 'MAP.bapID': targetBapId, 'MAP.targetBapID': bapId },
+        ],
+      }
+    : {
+        'MAP.bapID': bapId,
+      };
+
+  const [results, count] = await Promise.all([
+    dbo.collection('message').find(query).sort({ 'blk.t': -1 }).skip(skip).limit(limit).toArray(),
+    dbo.collection('message').countDocuments(query),
+  ]);
+
+  // Get unique signer addresses
+  const signerAddresses = new Set<string>();
+  for (const msg of results) {
+    if (!msg.AIP) continue;
+    for (const aip of msg.AIP) {
+      if (aip.algorithm_signing_component) {
+        signerAddresses.add(aip.algorithm_signing_component);
+      }
+      if (aip.address) {
+        signerAddresses.add(aip.address);
+      }
+    }
+  }
+
+  // Get BAP identities for all signers
+  const signers = await Promise.all(
+    Array.from(signerAddresses).map((address) => getBAPIdByAddress(address))
+  );
+
+  return {
+    bapID: bapId,
+    page,
+    limit,
+    count,
+    results: results.map((msg) => ({
+      ...msg,
+      MAP: msg.MAP.map((m) => ({
+        ...m,
+        bapID: m.bapID || '',
+      })),
+      B: msg.B.map((b) => ({
+        encoding: b?.encoding || '',
+        Data: {
+          utf8: b.Data?.utf8 || '',
+          data: b.Data?.data || '',
+        },
+      })),
+    })),
+    signers: signers.map((s) => ({
+      idKey: s.idKey,
+      rootAddress: s.rootAddress,
+      currentAddress: s.currentAddress,
+      addresses: s.addresses,
+      block: s.block || 0,
+      timestamp: s.timestamp || 0,
+      valid: s.valid ?? true,
+      identityTxId: s.identityTxId || '',
+      identity: typeof s.identity === 'string' ? s.identity : JSON.stringify(s.identity) || '',
+    })),
+  };
+}
+
+/**
+ * Creates a MongoDB change stream pipeline for watching direct messages between two BAP IDs
+ */
+export async function watchDirectMessages({
+  bapId,
+  bapAddress,
+  targetBapId,
+  targetAddress,
+}: MessageQueryParams): Promise<ChangeStream> {
+  const dbo = await getDbo();
+  return dbo.collection('message').watch([
+    {
+      $match: {
+        $or: [
+          {
+            $and: [
+              { 'fullDocument.MAP.bapID': bapId },
+              {
+                $or: [
+                  { 'fullDocument.AIP.algorithm_signing_component': targetAddress },
+                  { 'fullDocument.AIP.address': targetAddress },
+                ],
+              },
+            ],
+          },
+          {
+            $and: [
+              { 'fullDocument.MAP.bapID': targetBapId },
+              {
+                $or: [
+                  { 'fullDocument.AIP.algorithm_signing_component': bapAddress },
+                  { 'fullDocument.AIP.address': bapAddress },
+                ],
+              },
+            ],
+          },
+        ],
+      },
+    },
+  ]);
+}
+
+/**
+ * Creates a MongoDB change stream pipeline for watching all messages for a BAP ID
+ */
+export async function watchAllMessages({
+  bapId,
+  bapAddress,
+}: MessageQueryParams): Promise<ChangeStream> {
+  const dbo = await getDbo();
+  return dbo.collection('message').watch([
+    {
+      $match: {
+        $or: [
+          { 'fullDocument.MAP.bapID': bapId },
+          { 'fullDocument.AIP.algorithm_signing_component': bapAddress },
+          { 'fullDocument.AIP.address': bapAddress },
+        ],
+      },
+    },
+  ]);
+}
diff --git a/social/queries/channels.ts b/social/queries/channels.ts
new file mode 100644
index 0000000..3f9283f
--- /dev/null
+++ b/social/queries/channels.ts
@@ -0,0 +1,77 @@
+import type { CacheValue } from '../../cache.js';
+import { readFromRedis, saveToRedis } from '../../cache.js';
+import { getDbo } from '../../db.js';
+import type { ChannelInfo } from '../swagger/channels.js';
+
+export async function getChannels(): Promise<ChannelInfo[]> {
+  try {
+    const cacheKey = 'channels';
+    const cached = await readFromRedis<CacheValue>(cacheKey);
+
+    console.log('channels cache key', cacheKey);
+    if (cached?.type === 'channels') {
+      console.log('Cache hit for channels');
+      return cached.value;
+    }
+
+    console.log('Cache miss for channels');
+    const db = await getDbo();
+
+    try {
+      const pipeline = [
+        {
+          $match: {
+            'MAP.channel': { $exists: true, $ne: '' },
+          },
+        },
+        {
+          $unwind: '$MAP',
+        },
+        {
+          $unwind: '$B',
+        },
+        {
+          $group: {
+            _id: '$MAP.channel',
+            channel: { $first: '$MAP.channel' },
+            creator: { $first: { $ifNull: ['$MAP.paymail', null] } },
+            last_message: { $last: { $ifNull: ['$B.Data.utf8', null] } },
+            last_message_time: { $max: '$blk.t' },
+            messages: { $sum: 1 },
+          },
+        },
+        {
+          $sort: { last_message_time: -1 },
+        },
+        {
+          $limit: 100,
+        },
+      ];
+
+      console.log('Executing MongoDB aggregation');
+      const results = await db.collection('message').aggregate(pipeline).toArray();
+      console.log('Aggregation results:', results.length);
+
+      const channels = results.map((r) => ({
+        channel: r.channel,
+        creator: r.creator || null,
+        last_message: r.last_message || null,
+        last_message_time: r.last_message_time,
+        messages: r.messages,
+      }));
+
+      await saveToRedis<CacheValue>(cacheKey, {
+        type: 'channels',
+        value: channels,
+      });
+
+      return channels;
+    } catch (dbError) {
+      console.error('MongoDB operation failed:', dbError);
+      throw new Error('Failed to fetch channels');
+    }
+  } catch (error) {
+    console.error('getChannels error:', error);
+    throw error;
+  }
+}
diff --git a/social/queries/friends.ts b/social/queries/friends.ts
new file mode 100644
index 0000000..fa8e904
--- /dev/null
+++ b/social/queries/friends.ts
@@ -0,0 +1,248 @@
+import type { BmapTx } from 'bmapjs';
+import { getBAPIdByAddress } from '../../bap.js';
+import { getDbo } from '../../db.js';
+import type { Friend, FriendshipResponse, RelationshipState } from '../swagger/friend.js';
+import { fetchBapIdentityData } from './identity.js';
+
+export async function fetchAllFriendsAndUnfriends(
+  bapId: string
+): Promise<{ allDocs: BmapTx[]; ownedAddresses: Set<string> }> {
+  console.log('\n=== fetchAllFriendsAndUnfriends ===');
+  console.log('BAP ID:', bapId);
+
+  const dbo = await getDbo();
+
+  const idData = await fetchBapIdentityData(bapId);
+  if (!idData || !idData.addresses) {
+    throw new Error(`No identity found for ${bapId}`);
+  }
+
+  const ownedAddresses = new Set<string>(idData.addresses.map((a) => a.address));
+  console.log('Owned addresses:', [...ownedAddresses]);
+
+  // Get incoming friend requests (where this BAP ID is the target)
+  const incomingFriends = (await dbo
+    .collection('friend')
+    .find({ 'MAP.type': 'friend', 'MAP.bapID': bapId })
+    .toArray()) as unknown as BmapTx[];
+
+  console.log('Incoming friends count:', incomingFriends.length);
+  console.log(
+    'Incoming friends:',
+    JSON.stringify(
+      incomingFriends.map((f) => ({
+        txid: f.tx?.h,
+        bapID: f.MAP?.[0]?.bapID,
+        address: f.AIP?.[0]?.algorithm_signing_component || f.AIP?.[0]?.address,
+      })),
+      null,
+      2
+    )
+  );
+
+  // Get outgoing friend requests (where this BAP ID's addresses are the source)
+  const outgoingFriends = (await dbo
+    .collection('friend')
+    .find({
+      'MAP.type': 'friend',
+      $or: [
+        { 'AIP.algorithm_signing_component': { $in: [...ownedAddresses] } },
+        { 'AIP.address': { $in: [...ownedAddresses] } },
+      ],
+    })
+    .toArray()) as unknown as BmapTx[];
+
+  // Try to get unfriend documents if the collection exists
+  let incomingUnfriends: BmapTx[] = [];
+  let outgoingUnfriends: BmapTx[] = [];
+
+  try {
+    const collections = await dbo.listCollections().toArray();
+    const hasUnfriendCollection = collections.some((c) => c.name === 'unfriend');
+
+    if (hasUnfriendCollection) {
+      incomingUnfriends = (await dbo
+        .collection('unfriend')
+        .find({ 'MAP.type': 'unfriend', 'MAP.bapID': bapId })
+        .toArray()) as unknown as BmapTx[];
+
+      outgoingUnfriends = (await dbo
+        .collection('unfriend')
+        .find({
+          'MAP.type': 'unfriend',
+          $or: [
+            { 'AIP.algorithm_signing_component': { $in: [...ownedAddresses] } },
+            { 'AIP.address': { $in: [...ownedAddresses] } },
+          ],
+        })
+        .toArray()) as unknown as BmapTx[];
+    }
+  } catch (error) {
+    console.warn('Failed to query unfriend collection:', error);
+  }
+
+  console.log('Outgoing friends count:', outgoingFriends.length);
+  console.log(
+    'Outgoing friends:',
+    JSON.stringify(
+      outgoingFriends.map((f) => ({
+        txid: f.tx?.h,
+        bapID: f.MAP?.[0]?.bapID,
+        address: f.AIP?.[0]?.algorithm_signing_component || f.AIP?.[0]?.address,
+      })),
+      null,
+      2
+    )
+  );
+
+  const allDocs = [
+    ...incomingFriends,
+    ...incomingUnfriends,
+    ...outgoingFriends,
+    ...outgoingUnfriends,
+  ];
+  allDocs.sort((a, b) => (a.blk?.i ?? 0) - (b.blk?.i ?? 0));
+
+  console.log('Total documents:', allDocs.length);
+  return { allDocs, ownedAddresses };
+}
+
+export async function processRelationships(
+  bapId: string,
+  docs: BmapTx[],
+  ownedAddresses: Set<string>
+): Promise<FriendshipResponse> {
+  console.log('\n=== processRelationships ===');
+  console.log('Processing relationships for BAP ID:', bapId);
+  console.log('Number of documents:', docs.length);
+  console.log('Owned addresses:', [...ownedAddresses]);
+
+  const relationships = new Map<string, RelationshipState>();
+
+  async function getRequestorBapId(doc: BmapTx): Promise<string | null> {
+    // Check all possible address fields
+    const address = doc?.AIP?.[0]?.algorithm_signing_component || doc?.AIP?.[0]?.address;
+    if (!address) {
+      console.log('No address found in document:', doc.tx?.h);
+      return null;
+    }
+
+    if (ownedAddresses.has(address)) {
+      console.log('Address matches owned address:', address);
+      return bapId;
+    }
+
+    console.log('Looking up BAP ID for address:', address);
+    const otherIdentity = await getBAPIdByAddress(address);
+    if (!otherIdentity) {
+      console.log('No identity found for address:', address);
+      return null;
+    }
+    console.log('Found BAP ID for address:', otherIdentity.idKey);
+    return otherIdentity.idKey;
+  }
+
+  const requestors = await Promise.all(docs.map((doc) => getRequestorBapId(doc)));
+  console.log('Resolved requestors:', requestors);
+
+  for (let i = 0; i < docs.length; i++) {
+    const doc = docs[i];
+    const reqBap = requestors[i];
+    const tgtBap = doc?.MAP?.[0]?.bapID;
+    const publicKey = doc?.MAP?.[0]?.publicKey;
+
+    console.log('\nProcessing document:', doc.tx?.h);
+    console.log('Requestor BAP:', reqBap);
+    console.log('Target BAP:', tgtBap);
+
+    if (!reqBap || !tgtBap || !Array.isArray(doc.MAP)) {
+      console.log('Skipping document - missing required fields');
+      continue;
+    }
+
+    const otherBapId = reqBap === bapId ? tgtBap : reqBap;
+    console.log('Other BAP ID:', otherBapId);
+
+    if (otherBapId && typeof otherBapId === 'string' && !relationships.has(otherBapId)) {
+      console.log('Creating new relationship for:', otherBapId);
+      relationships.set(otherBapId, { fromMe: false, fromThem: false, unfriended: false });
+    }
+
+    const rel = relationships.get(typeof otherBapId === 'string' ? otherBapId : '');
+    if (!rel) {
+      console.log('No relationship found for:', otherBapId);
+      continue;
+    }
+
+    const isFriend = doc?.MAP?.[0]?.type === 'friend';
+    const isUnfriend = doc?.MAP?.[0]?.type === 'unfriend';
+    const isFromMe = reqBap === bapId;
+
+    console.log('Document type:', isFriend ? 'friend' : isUnfriend ? 'unfriend' : 'unknown');
+    console.log('Is from me:', isFromMe);
+
+    if (isUnfriend) {
+      console.log('Processing unfriend');
+      rel.unfriended = true;
+      rel.fromMe = false;
+      rel.fromThem = false;
+    } else if (isFriend) {
+      console.log('Processing friend');
+      if (rel.unfriended) {
+        rel.unfriended = false;
+      }
+      if (isFromMe) {
+        rel.fromMe = true;
+        rel.mePublicKey = publicKey;
+      } else {
+        rel.fromThem = true;
+        rel.themPublicKey = publicKey;
+      }
+    }
+
+    console.log(
+      'Updated relationship:',
+      JSON.stringify({
+        otherBapId,
+        fromMe: rel.fromMe,
+        fromThem: rel.fromThem,
+        unfriended: rel.unfriended,
+      })
+    );
+  }
+
+  const friends: Friend[] = [];
+  const incoming: string[] = [];
+  const outgoing: string[] = [];
+
+  console.log('\nFinal relationships:');
+  for (const [other, rel] of relationships.entries()) {
+    console.log('Processing final relationship:', other, JSON.stringify(rel));
+
+    if (rel.unfriended) {
+      console.log('Skipping unfriended relationship:', other);
+      continue;
+    }
+    if (rel.fromMe && rel.fromThem) {
+      console.log('Adding mutual friend:', other);
+      friends.push({
+        bapID: other,
+        mePublicKey: rel.mePublicKey || '',
+        themPublicKey: rel.themPublicKey || '',
+      });
+    } else if (rel.fromMe && !rel.fromThem) {
+      console.log('Adding outgoing friend:', other);
+      outgoing.push(other);
+    } else if (!rel.fromMe && rel.fromThem) {
+      console.log('Adding incoming friend:', other);
+      incoming.push(other);
+    }
+  }
+
+  console.log('\nFinal results:');
+  console.log('Friends:', friends);
+  console.log('Incoming:', incoming);
+  console.log('Outgoing:', outgoing);
+
+  return { friends, incoming, outgoing };
+}
diff --git a/social/queries/identities.ts b/social/queries/identities.ts
new file mode 100644
index 0000000..80323a4
--- /dev/null
+++ b/social/queries/identities.ts
@@ -0,0 +1,107 @@
+import type { BapIdentity } from '../../bap.js';
+import type { CacheError, CacheValue } from '../../cache.js';
+import { client, readFromRedis, saveToRedis } from '../../cache.js';
+import type { Identity } from '../swagger/identity.js';
+import { validateSignerData } from './identity.js';
+
+export async function getAllIdentities(): Promise<Identity[]> {
+  // Check Redis connection
+  console.log('Checking Redis connection...');
+  if (!client.isReady) {
+    console.error('Redis client is not ready');
+    return [];
+  }
+
+  // First try to get the cached identities list
+  const identitiesCacheKey = 'identities';
+  const cachedIdentities = await readFromRedis<CacheValue | CacheError>(identitiesCacheKey);
+
+  if (cachedIdentities?.type === 'identities' && Array.isArray(cachedIdentities.value)) {
+    console.log('Using cached identities list');
+    return cachedIdentities.value;
+  }
+
+  // If no cached list, get all signer-* keys from Redis
+  console.log('No cached identities list, checking individual signer caches');
+  const signerKeys = await client.keys('signer-*');
+  console.log(`Found ${signerKeys.length} cached signers`);
+
+  if (!signerKeys.length) {
+    console.log('No cached signers found');
+    return [];
+  }
+
+  // Get all cached signers
+  const identities = await Promise.all(
+    signerKeys.map(async (key) => {
+      try {
+        const cachedValue = await readFromRedis<CacheValue | CacheError>(key);
+        if (cachedValue?.type === 'signer' && 'value' in cachedValue) {
+          const identity = cachedValue.value;
+          if (identity && validateSignerData(identity).isValid) {
+            return {
+              idKey: identity.idKey || '',
+              rootAddress: identity.rootAddress || '',
+              currentAddress: identity.currentAddress || '',
+              addresses: Array.isArray(identity.addresses)
+                ? identity.addresses.map((addr) => ({
+                    address: addr.address || '',
+                    txId: addr.txId || '',
+                    block: typeof addr.block === 'number' ? addr.block : undefined,
+                  }))
+                : [],
+              identity:
+                typeof identity.identity === 'string'
+                  ? identity.identity
+                  : typeof identity.identity === 'object'
+                    ? identity.identity
+                    : JSON.stringify(identity.identity || {}),
+              identityTxId: identity.identityTxId || '',
+              block: typeof identity.block === 'number' ? identity.block : 0,
+              timestamp: typeof identity.timestamp === 'number' ? identity.timestamp : 0,
+              valid: typeof identity.valid === 'boolean' ? identity.valid : true,
+            };
+          }
+        }
+        return null;
+      } catch (error) {
+        console.error(`Error processing cached signer ${key}:`, error);
+        return null;
+      }
+    })
+  );
+
+  const filteredIdentities = identities.filter((id): id is Identity => {
+    if (!id) return false;
+    return (
+      typeof id.idKey === 'string' &&
+      typeof id.rootAddress === 'string' &&
+      typeof id.currentAddress === 'string' &&
+      Array.isArray(id.addresses) &&
+      id.addresses.every(
+        (addr) =>
+          typeof addr.address === 'string' &&
+          typeof addr.txId === 'string' &&
+          (typeof addr.block === 'number' || addr.block === undefined)
+      ) &&
+      (typeof id.identity === 'string' || typeof id.identity === 'object') &&
+      typeof id.identityTxId === 'string' &&
+      typeof id.block === 'number' &&
+      typeof id.timestamp === 'number' &&
+      typeof id.valid === 'boolean'
+    );
+  });
+
+  console.log('\n=== Identity Processing Summary ===');
+  console.log('Total cached signers:', signerKeys.length);
+  console.log('Successfully processed:', filteredIdentities.length);
+  console.log('Failed/invalid:', signerKeys.length - filteredIdentities.length);
+
+  // Cache the filtered list
+  await saveToRedis<CacheValue>(identitiesCacheKey, {
+    type: 'identities',
+    value: filteredIdentities,
+  });
+
+  return filteredIdentities;
+}
diff --git a/social/queries/identity.ts b/social/queries/identity.ts
new file mode 100644
index 0000000..362d886
--- /dev/null
+++ b/social/queries/identity.ts
@@ -0,0 +1,69 @@
+import type { BapIdentity } from '../../bap.js';
+import type { CacheValue } from '../../cache.js';
+import { readFromRedis, saveToRedis } from '../../cache.js';
+import type { SigmaIdentityAPIResponse, SigmaIdentityResult } from '../swagger/identity.js';
+
+export function sigmaIdentityToBapIdentity(result: SigmaIdentityResult): BapIdentity {
+  return {
+    idKey: result.idKey,
+    rootAddress: result.rootAddress,
+    currentAddress: result.currentAddress,
+    addresses: result.addresses,
+    identity: result.identity,
+    identityTxId: result.identityTxId,
+    block: result.block,
+    timestamp: result.timestamp,
+    valid: result.valid,
+  };
+}
+
+export async function fetchBapIdentityData(bapId: string): Promise<BapIdentity> {
+  const cacheKey = `sigmaIdentity-${bapId}`;
+  const cached = await readFromRedis<CacheValue>(cacheKey);
+  if (cached?.type === 'signer') {
+    return cached.value;
+  }
+
+  const url = 'https://api.sigmaidentity.com/v1/identity/get';
+  const resp = await fetch(url, {
+    method: 'POST',
+    headers: { 'Content-Type': 'application/json' },
+    body: JSON.stringify({ idKey: bapId }),
+  });
+
+  if (!resp.ok) {
+    const text = await resp.text();
+    throw new Error(`Failed to fetch identity data. Status: ${resp.status}, Body: ${text}`);
+  }
+
+  const data: SigmaIdentityAPIResponse = await resp.json();
+  if (data.status !== 'OK' || !data.result || data.error) {
+    throw new Error(
+      `Sigma Identity returned invalid data for ${bapId}: ${data.error || 'Unknown error'}`
+    );
+  }
+
+  const bapIdentity = sigmaIdentityToBapIdentity(data.result);
+
+  await saveToRedis<CacheValue>(cacheKey, {
+    type: 'signer',
+    value: bapIdentity,
+  });
+
+  return bapIdentity;
+}
+
+// Validation helper for signer data
+export function validateSignerData(signer: BapIdentity): { isValid: boolean; errors: string[] } {
+  const errors: string[] = [];
+
+  if (!signer.idKey) errors.push('Missing idKey');
+  if (!signer.currentAddress) errors.push('Missing currentAddress');
+  if (!signer.rootAddress) errors.push('Missing rootAddress');
+  if (!signer.addresses || !signer.addresses.length) errors.push('Missing addresses');
+
+  return {
+    isValid: errors.length === 0,
+    errors,
+  };
+}
diff --git a/social/queries/likes.ts b/social/queries/likes.ts
new file mode 100644
index 0000000..6667680
--- /dev/null
+++ b/social/queries/likes.ts
@@ -0,0 +1,149 @@
+import type { BapIdentity } from '../../bap.js';
+import { getBAPIdByAddress } from '../../bap.js';
+import type { CacheValue } from '../../cache.js';
+import { readFromRedis, saveToRedis } from '../../cache.js';
+import { getDbo } from '../../db.js';
+import type { LikeRequest, LikeResponse, Reaction } from '../swagger/likes.js';
+import { validateSignerData } from './identity.js';
+
+// Helper to process likes with better error handling and logging
+export async function processLikes(
+  likes: Reaction[]
+): Promise<{ signerIds: string[]; signers: BapIdentity[] }> {
+  console.log('Processing likes:', likes.length);
+
+  // Get unique signer addresses with validation
+  const signerAddresses = new Set<string>();
+  const invalidLikes: string[] = [];
+
+  for (const like of likes) {
+    if (!Array.isArray(like.AIP)) {
+      console.warn('Invalid like document - missing AIP array:', like.tx?.h);
+      invalidLikes.push(like.tx?.h);
+      continue;
+    }
+
+    for (const aip of like.AIP) {
+      if (!aip.algorithm_signing_component) {
+        console.warn('Invalid AIP entry - missing algorithm_signing_component:', like.tx?.h);
+        continue;
+      }
+      signerAddresses.add(aip.algorithm_signing_component);
+    }
+  }
+
+  if (invalidLikes.length > 0) {
+    console.warn('Found invalid like documents:', invalidLikes);
+  }
+
+  console.log('Found unique signer addresses:', signerAddresses.size);
+
+  // Fetch and validate signer identities
+  const signerIds = Array.from(signerAddresses);
+  const signerResults = await Promise.all(
+    signerIds.map(async (address) => {
+      const signerCacheKey = `signer-${address}`;
+      const cachedSigner = await readFromRedis<CacheValue>(signerCacheKey);
+
+      if (cachedSigner?.type === 'signer' && cachedSigner.value) {
+        const validation = validateSignerData(cachedSigner.value);
+        if (!validation.isValid) {
+          console.warn(
+            'Invalid cached signer data for address:',
+            address,
+            'Errors:',
+            validation.errors
+          );
+          return null;
+        }
+        return cachedSigner.value;
+      }
+
+      try {
+        const identity = await getBAPIdByAddress(address);
+        if (identity) {
+          const validation = validateSignerData(identity);
+          if (!validation.isValid) {
+            console.warn(
+              'Invalid fetched signer data for address:',
+              address,
+              'Errors:',
+              validation.errors
+            );
+            return null;
+          }
+
+          await saveToRedis<CacheValue>(signerCacheKey, {
+            type: 'signer',
+            value: identity,
+          });
+          return identity;
+        }
+      } catch (error) {
+        console.error(`Failed to fetch identity for address ${address}:`, error);
+      }
+      return null;
+    })
+  );
+
+  const validSigners = signerResults.filter((s): s is BapIdentity => s !== null);
+  console.log('Successfully processed signers:', validSigners.length);
+
+  return {
+    signerIds: validSigners.map((s) => s.idKey),
+    signers: validSigners,
+  };
+}
+
+export async function getLikes(request: LikeRequest): Promise<LikeResponse[]> {
+  if (!request.txids && !request.messageIds) {
+    throw new Error('Must provide either txids or messageIds');
+  }
+
+  const db = await getDbo();
+  const results: LikeResponse[] = [];
+
+  if (request.txids) {
+    for (const txid of request.txids) {
+      const likes = (await db
+        .collection('like')
+        .find({
+          'MAP.type': 'like',
+          'MAP.tx': txid,
+        })
+        .toArray()) as unknown as Reaction[];
+
+      const { signers } = await processLikes(likes);
+
+      results.push({
+        txid,
+        likes,
+        total: likes.length,
+        signers,
+      });
+    }
+  }
+
+  if (request.messageIds) {
+    for (const messageId of request.messageIds) {
+      const likes = (await db
+        .collection('like')
+        .find({
+          'MAP.type': 'like',
+          'MAP.messageID': messageId,
+        })
+        .toArray()) as unknown as Reaction[];
+
+      const { signers } = await processLikes(likes);
+
+      results.push({
+        txid: messageId,
+        likes,
+        total: likes.length,
+        signers,
+      });
+    }
+  }
+
+  return results;
+}
diff --git a/social/queries/messages.ts b/social/queries/messages.ts
new file mode 100644
index 0000000..d080f12
--- /dev/null
+++ b/social/queries/messages.ts
@@ -0,0 +1,178 @@
+import type { BapIdentity } from '../../bap.js';
+import { getBAPIdByAddress } from '../../bap.js';
+import type { CacheValue } from '../../cache.js';
+import { client, readFromRedis, saveToRedis } from '../../cache.js';
+import { getDbo } from '../../db.js';
+import type { ChannelMessage, Message } from '../swagger/messages.js';
+
+// Helper function to merge new signers into cache
+export async function updateSignerCache(newSigners: BapIdentity[]): Promise<void> {
+  for (const signer of newSigners) {
+    const signerKey = `signer-${signer.currentAddress}`;
+    await saveToRedis<CacheValue>(signerKey, {
+      type: 'signer',
+      value: signer,
+    });
+  }
+  // Clear the identities cache to force a refresh with new signers
+  await client.del('identities');
+}
+
+// Helper function to resolve signers from messages
+export async function resolveSigners(messages: Message[]): Promise<BapIdentity[]> {
+  const signerAddresses = new Set<string>();
+
+  for (const msg of messages) {
+    if (msg.AIP && Array.isArray(msg.AIP)) {
+      for (const aip of msg.AIP) {
+        const address = aip.algorithm_signing_component || aip.address;
+        if (address) {
+          signerAddresses.add(address);
+        }
+      }
+    }
+  }
+
+  const signers = await Promise.all(
+    Array.from(signerAddresses).map(async (address) => {
+      try {
+        const identity = await getBAPIdByAddress(address);
+        if (identity) {
+          // Update the signer cache with this identity
+          const signerKey = `signer-${address}`;
+          await saveToRedis<CacheValue>(signerKey, {
+            type: 'signer',
+            value: identity,
+          });
+          return identity;
+        }
+      } catch (error) {
+        console.error(`Failed to resolve signer for address ${address}:`, error);
+      }
+      return null;
+    })
+  );
+
+  const validSigners = signers.filter((s): s is BapIdentity => s !== null);
+
+  // Update the cache with new signers
+  await updateSignerCache(validSigners);
+
+  return validSigners;
+}
+
+export async function getChannelMessages(params: {
+  channelId: string;
+  page: number;
+  limit: number;
+}): Promise<ChannelMessage> {
+  const { channelId, page, limit } = params;
+  const skip = (page - 1) * limit;
+  const decodedChannelId = decodeURIComponent(channelId);
+
+  const cacheKey = `messages:${decodedChannelId}:${page}:${limit}`;
+  const cached = await readFromRedis<CacheValue>(cacheKey);
+
+  if (cached?.type === 'messages') {
+    console.log('Cache hit for messages:', cacheKey);
+    return {
+      ...cached.value,
+      channel: channelId,
+      signers: cached.value.signers || [],
+    };
+  }
+
+  console.log('Cache miss for messages:', cacheKey);
+  const db = await getDbo();
+
+  const queryObj = {
+    'MAP.type': 'message',
+    'MAP.channel': decodedChannelId,
+  };
+
+  const col = db.collection('message');
+  const count = await col.countDocuments(queryObj);
+
+  const results = (await col
+    .find(queryObj)
+    .sort({ 'blk.t': -1 })
+    .skip(skip)
+    .limit(limit)
+    .project({ _id: 0 })
+    .toArray()) as Message[];
+
+  // Normalize and validate each message
+  const validatedResults = results.map((msg) => ({
+    ...msg,
+    tx: { h: msg.tx?.h || '' },
+    blk: { i: msg.blk?.i || 0, t: msg.blk?.t || 0 },
+    MAP: msg.MAP?.map((m) => ({
+      app: m.app || '',
+      type: m.type || '',
+      channel: m.channel || '',
+      paymail: m.paymail || '',
+    })) || [
+      {
+        app: '',
+        type: '',
+        channel: '',
+        paymail: '',
+      },
+    ],
+    B: msg.B?.map((b) => ({
+      encoding: b?.encoding || '',
+      Data: {
+        utf8: b.Data?.utf8 || '',
+        data: b.Data?.data,
+      },
+    })) || [
+      {
+        encoding: '',
+        Data: {
+          utf8: '',
+          data: '',
+        },
+      },
+    ],
+  }));
+
+  // Initialize empty signers array with proper type
+  let signers: BapIdentity[] = [];
+
+  // Only try to resolve signers if there are messages with AIP data
+  const messagesWithAIP = results.filter((msg) => msg.AIP && msg.AIP.length > 0);
+  if (messagesWithAIP.length > 0) {
+    try {
+      signers = await resolveSigners(messagesWithAIP);
+      console.log(`Resolved ${signers.length} signers`);
+    } catch (error) {
+      console.error('Error resolving signers:', error);
+      // Don't throw - continue with empty signers array
+    }
+  } else {
+    console.log('No messages with AIP data found');
+  }
+
+  // Ensure signers array is properly initialized with all required fields
+  const validatedSigners: BapIdentity[] = signers.map((s) => ({
+    ...s,
+    identityTxId: s.identityTxId || '',
+    identity: typeof s.identity === 'string' ? s.identity : JSON.stringify(s.identity) || '',
+  }));
+
+  const response: ChannelMessage = {
+    channel: channelId,
+    page,
+    limit,
+    count,
+    results: validatedResults,
+    signers: validatedSigners,
+  };
+
+  await saveToRedis<CacheValue>(cacheKey, {
+    type: 'messages',
+    value: response,
+  });
+
+  return response;
+}
diff --git a/social.ts b/social/routes.ts
similarity index 76%
rename from social.ts
rename to social/routes.ts
index a0884a7..ddb20af 100644
--- a/social.ts
+++ b/social/routes.ts
@@ -1,186 +1,48 @@
 import type { BmapTx } from 'bmapjs';
-import type { ServerWebSocket } from 'bun';
 import { Elysia, t } from 'elysia';
 import { InternalServerError, error } from 'elysia';
 import * as mongo from 'mongodb';
 import type { ChangeStream, ChangeStreamDocument, ChangeStreamInsertDocument, Db } from 'mongodb';
-import { getBAPIdByAddress } from './bap.js';
-import type { BapIdentity } from './bap.js';
-import { normalize } from './bmap.js';
-import { client, readFromRedis, saveToRedis } from './cache.js';
-import type { CacheValue as BaseCacheValue, CacheError, CacheSigner } from './cache.js';
-import { getDbo } from './db.js';
+import { getBAPIdByAddress } from '../bap.js';
+import type { BapIdentity } from '../bap.js';
+import { normalize } from '../bmap.js';
+import { client, readFromRedis, saveToRedis } from '../cache.js';
+import type { CacheError, CacheSigner, CacheValue } from '../cache.js';
+import { getDbo } from '../db.js';
+import { getDirectMessages, watchAllMessages, watchDirectMessages } from '../queries/messages.js';
 import { ChannelResponseSchema, channelsEndpointDetail } from './swagger/channels.js';
+import type { ChannelInfo } from './swagger/channels.js';
+import type { Friend, FriendshipResponse, RelationshipState } from './swagger/friend.js';
 import { FriendResponseSchema, friendEndpointDetail } from './swagger/friend.js';
+import { IdentityResponseSchema, identityEndpointDetail } from './swagger/identity.js';
+import type {
+  Identity,
+  SigmaIdentityAPIResponse,
+  SigmaIdentityResult,
+} from './swagger/identity.js';
+import type { LikeRequest, LikeResponse, Reaction, Reactions } from './swagger/likes.js';
+import { LikeRequestSchema, LikeResponseSchema } from './swagger/likes.js';
+import type { ChannelMessage, Message } from './swagger/messages.js';
 import {
   ChannelMessageSchema,
+  DMResponseSchema,
+  MessageListenParams,
   MessageQuery,
   channelMessagesEndpointDetail,
+  messageListenEndpointDetail,
 } from './swagger/messages.js';
 
-// Extend CacheValue type
-export type CacheValue =
-  | BaseCacheValue
-  | {
-      type: 'identities';
-      value: Identity[];
-    };
-
-interface SigmaIdentityAPIResponse {
-  status: string;
-  result?: SigmaIdentityResult;
-  error?: string;
-}
-
-interface SigmaIdentityResult {
-  idKey: string;
-  rootAddress: string;
-  currentAddress: string;
-  addresses: {
-    address: string;
-    txId: string;
-    block?: number;
-  }[];
-  identity?: Record<string, unknown>;
-  block?: number;
-  timestamp?: number;
-  valid?: boolean;
-}
-
-interface RelationshipState {
-  fromMe: boolean;
-  fromThem: boolean;
-  mePublicKey?: string;
-  themPublicKey?: string;
-  unfriended: boolean;
-}
-
-interface FriendshipResponse {
-  friends: Friend[];
-  incoming: string[];
-  outgoing: string[];
-}
-
-interface Friend {
-  bapID: string;
-  themPublicKey: string;
-  mePublicKey: string;
-}
-
-export interface Reactions {
-  channel: string;
-  page: number;
-  limit: number;
-  count: number;
-  results: Reaction[];
-}
-
-export interface ChannelInfo {
-  channel: string;
-  creator: string;
-  last_message: string;
-  last_message_time: number;
-  messages: number;
-}
-
-export interface DMResponse {
-  bapID: string;
-  page: number;
-  limit: number;
-  count: number;
-  results: Message[];
-  signers: BapIdentity[];
-}
-
-export interface ChannelMessage {
-  channel: string;
-  page: number;
-  limit: number;
-  count: number;
-  results: Message[];
-  signers: BapIdentity[];
-}
-
-interface Message {
-  tx: {
-    h: string;
-  };
-  blk: {
-    i: number;
-    t: number;
-  };
-  MAP: {
-    app: string;
-    type: string;
-    paymail?: string;
-    context?: string;
-    channel?: string;
-    bapID?: string;
-  }[];
-  B: {
-    encoding: string;
-    Data: {
-      utf8: string;
-      data?: string;
-    };
-  }[];
-  AIP?: {
-    algorithm: string;
-    address: string;
-    algorithm_signing_component: string;
-  }[];
-}
-
-interface LikeRequest {
-  txids?: string[];
-  messageIds?: string[];
-}
-
-interface Reaction {
-  tx: {
-    h: string;
-  };
-  blk: {
-    i: number;
-    t: number;
-  };
-  MAP: {
-    type: string;
-    tx?: string;
-    messageID?: string;
-    emoji?: string;
-  }[];
-  AIP?: {
-    algorithm_signing_component: string;
-  }[];
-}
-
-export interface LikeInfo {
-  txid: string;
-  likes: Reaction[];
-  total: number;
-  signerIds: string[]; // Store only signer IDs
-}
-
-interface LikeResponse {
-  txid: string;
-  likes: Reaction[];
-  total: number;
-  signers: BapIdentity[]; // Full signer objects for API response
-}
-
 function sigmaIdentityToBapIdentity(result: SigmaIdentityResult): BapIdentity {
-  const identity = result.identity || '';
   return {
     idKey: result.idKey,
     rootAddress: result.rootAddress,
     currentAddress: result.currentAddress,
     addresses: result.addresses,
-    identity: typeof identity === 'string' ? identity : JSON.stringify(identity),
-    identityTxId: result.addresses[0]?.txId || '', // fallback if not present
-    block: result.block || 0,
-    timestamp: result.timestamp || 0,
-    valid: result.valid ?? true,
+    identity: result.identity,
+    identityTxId: result.identityTxId,
+    block: result.block,
+    timestamp: result.timestamp,
+    valid: result.valid,
   };
 }
 
@@ -204,8 +66,10 @@ async function fetchBapIdentityData(bapId: string): Promise<BapIdentity> {
   }
 
   const data: SigmaIdentityAPIResponse = await resp.json();
-  if (data.status !== 'OK' || !data.result) {
-    throw new Error(`Sigma Identity returned invalid data for ${bapId}`);
+  if (data.status !== 'OK' || !data.result || data.error) {
+    throw new Error(
+      `Sigma Identity returned invalid data for ${bapId}: ${data.error || 'Unknown error'}`
+    );
   }
 
   const bapIdentity = sigmaIdentityToBapIdentity(data.result);
@@ -476,105 +340,6 @@ function validateSignerData(signer: BapIdentity): { isValid: boolean; errors: st
   };
 }
 
-// Helper to process likes with better error handling and logging
-async function processLikes(
-  likes: Reaction[]
-): Promise<{ signerIds: string[]; signers: BapIdentity[] }> {
-  console.log('Processing likes:', likes.length);
-
-  // Get unique signer addresses with validation
-  const signerAddresses = new Set<string>();
-  const invalidLikes: string[] = [];
-
-  for (const like of likes) {
-    if (!Array.isArray(like.AIP)) {
-      console.warn('Invalid like document - missing AIP array:', like.tx?.h);
-      invalidLikes.push(like.tx?.h);
-      continue;
-    }
-
-    for (const aip of like.AIP) {
-      if (!aip.algorithm_signing_component) {
-        console.warn('Invalid AIP entry - missing algorithm_signing_component:', like.tx?.h);
-        continue;
-      }
-      signerAddresses.add(aip.algorithm_signing_component);
-    }
-  }
-
-  if (invalidLikes.length > 0) {
-    console.warn('Found invalid like documents:', invalidLikes);
-  }
-
-  console.log('Found unique signer addresses:', signerAddresses.size);
-
-  // Fetch and validate signer identities
-  const signerIds = Array.from(signerAddresses);
-  const signerResults = await Promise.all(
-    signerIds.map(async (address) => {
-      const signerCacheKey = `signer-${address}`;
-      const cachedSigner = await readFromRedis<CacheValue>(signerCacheKey);
-
-      if (cachedSigner?.type === 'signer' && cachedSigner.value) {
-        const validation = validateSignerData(cachedSigner.value);
-        if (!validation.isValid) {
-          console.warn(
-            'Invalid cached signer data for address:',
-            address,
-            'Errors:',
-            validation.errors
-          );
-          return null;
-        }
-        return cachedSigner.value;
-      }
-
-      try {
-        const identity = await getBAPIdByAddress(address);
-        if (identity) {
-          const validation = validateSignerData(identity);
-          if (!validation.isValid) {
-            console.warn(
-              'Invalid fetched signer data for address:',
-              address,
-              'Errors:',
-              validation.errors
-            );
-            return null;
-          }
-
-          await saveToRedis<CacheValue>(signerCacheKey, {
-            type: 'signer',
-            value: identity,
-          });
-          return identity;
-        }
-      } catch (error) {
-        console.error(`Failed to fetch identity for address ${address}:`, error);
-      }
-      return null;
-    })
-  );
-
-  const validSigners = signerResults.filter((s): s is BapIdentity => s !== null);
-  console.log('Successfully processed signers:', validSigners.length);
-
-  return {
-    signerIds: validSigners.map((s) => s.idKey),
-    signers: validSigners,
-  };
-}
-
-// Define request schemas
-const LikeRequest = t.Object({
-  txids: t.Optional(t.Array(t.String())),
-  messageIds: t.Optional(t.Array(t.String())),
-});
-
-const ChannelParams = t.Object({
-  channelId: t.String(),
-});
-
 // Helper function to merge new signers into cache
 async function updateSignerCache(newSigners: BapIdentity[]): Promise<void> {
   for (const signer of newSigners) {
@@ -631,163 +396,6 @@ async function resolveSigners(messages: Message[]): Promise<BapIdentity[]> {
   return validSigners;
 }
 
-// Define the Identity interface
-export interface Identity {
-  idKey: string;
-  rootAddress: string;
-  currentAddress: string;
-  addresses: {
-    address: string;
-    txId: string;
-    block: number | undefined;
-  }[];
-  identity: string;
-  identityTxId: string;
-  block: number;
-  timestamp: number;
-  valid: boolean;
-}
-
-export const IdentityResponse = t.Array(
-  t.Object({
-    idKey: t.String(),
-    rootAddress: t.String(),
-    currentAddress: t.String(),
-    addresses: t.Array(
-      t.Object({
-        address: t.String(),
-        txId: t.String(),
-        block: t.Optional(t.Number()),
-      })
-    ),
-    identity: t.String(),
-    identityTxId: t.String(),
-    block: t.Number(),
-    timestamp: t.Number(),
-    valid: t.Boolean(),
-  })
-);
-
-const DMResponse = t.Object({
-  bapID: t.String(),
-  page: t.Number(),
-  limit: t.Number(),
-  count: t.Number(),
-  results: t.Array(
-    t.Object({
-      timestamp: t.Number(),
-      tx: t.Object({
-        h: t.String(),
-      }),
-      blk: t.Object({
-        i: t.Number(),
-        t: t.Number(),
-      }),
-      MAP: t.Array(
-        t.Object({
-          app: t.String(),
-          type: t.String(),
-          bapID: t.String(),
-          encrypted: t.Optional(t.String()),
-          context: t.Literal('bapID'),
-        })
-      ),
-      B: t.Array(
-        t.Object({
-          Data: t.Object({
-            utf8: t.String(),
-            data: t.Optional(t.String()),
-          }),
-          encoding: t.String(),
-        })
-      ),
-      AIP: t.Optional(
-        t.Array(
-          t.Object({
-            algorithm: t.String(),
-            address: t.Optional(t.String()),
-            algorithm_signing_component: t.Optional(t.String()),
-          })
-        )
-      ),
-    })
-  ),
-  signers: t.Array(
-    t.Object({
-      idKey: t.String(),
-      rootAddress: t.String(),
-      currentAddress: t.String(),
-      addresses: t.Array(
-        t.Object({
-          address: t.String(),
-          txId: t.String(),
-          block: t.Optional(t.Number()),
-        })
-      ),
-      identity: t.String(),
-      identityTxId: t.String(),
-      block: t.Number(),
-      timestamp: t.Number(),
-      valid: t.Boolean(),
-    })
-  ),
-});
-
-const LikeResponse = t.Array(
-  t.Object({
-    txid: t.String(),
-    likes: t.Array(
-      t.Object({
-        tx: t.Object({
-          h: t.String(),
-        }),
-        blk: t.Object({
-          i: t.Number(),
-          t: t.Number(),
-        }),
-        MAP: t.Array(
-          t.Object({
-            type: t.String(),
-            tx: t.Optional(t.String()),
-            messageID: t.Optional(t.String()),
-            emoji: t.Optional(t.String()),
-          })
-        ),
-        AIP: t.Optional(
-          t.Array(
-            t.Object({
-              algorithm_signing_component: t.String(),
-            })
-          )
-        ),
-      })
-    ),
-    total: t.Number(),
-    signers: t.Array(
-      t.Object({
-        idKey: t.String(),
-        rootAddress: t.String(),
-        currentAddress: t.String(),
-        addresses: t.Array(
-          t.Object({
-            address: t.String(),
-            txId: t.String(),
-            block: t.Optional(t.Number()),
-          })
-        ),
-        identity: t.String(),
-        identityTxId: t.String(),
-        block: t.Number(),
-        timestamp: t.Number(),
-        valid: t.Boolean(),
-      })
-    ),
-  })
-);
-
-// Update CacheListResponse type
-export interface CacheListResponse extends Array<Identity> {}
-
 async function getChannels() {
   try {
     const cacheKey = 'channels';
@@ -861,6 +469,99 @@ async function getChannels() {
   }
 }
 
+// Helper to process likes with better error handling and logging
+async function processLikes(
+  likes: Reaction[]
+): Promise<{ signerIds: string[]; signers: BapIdentity[] }> {
+  console.log('Processing likes:', likes.length);
+
+  // Get unique signer addresses with validation
+  const signerAddresses = new Set<string>();
+  const invalidLikes: string[] = [];
+
+  for (const like of likes) {
+    if (!Array.isArray(like.AIP)) {
+      console.warn('Invalid like document - missing AIP array:', like.tx?.h);
+      invalidLikes.push(like.tx?.h);
+      continue;
+    }
+
+    for (const aip of like.AIP) {
+      if (!aip.algorithm_signing_component) {
+        console.warn('Invalid AIP entry - missing algorithm_signing_component:', like.tx?.h);
+        continue;
+      }
+      signerAddresses.add(aip.algorithm_signing_component);
+    }
+  }
+
+  if (invalidLikes.length > 0) {
+    console.warn('Found invalid like documents:', invalidLikes);
+  }
+
+  console.log('Found unique signer addresses:', signerAddresses.size);
+
+  // Fetch and validate signer identities
+  const signerIds = Array.from(signerAddresses);
+  const signerResults = await Promise.all(
+    signerIds.map(async (address) => {
+      const signerCacheKey = `signer-${address}`;
+      const cachedSigner = await readFromRedis<CacheValue>(signerCacheKey);
+
+      if (cachedSigner?.type === 'signer' && cachedSigner.value) {
+        const validation = validateSignerData(cachedSigner.value);
+        if (!validation.isValid) {
+          console.warn(
+            'Invalid cached signer data for address:',
+            address,
+            'Errors:',
+            validation.errors
+          );
+          return null;
+        }
+        return cachedSigner.value;
+      }
+
+      try {
+        const identity = await getBAPIdByAddress(address);
+        if (identity) {
+          const validation = validateSignerData(identity);
+          if (!validation.isValid) {
+            console.warn(
+              'Invalid fetched signer data for address:',
+              address,
+              'Errors:',
+              validation.errors
+            );
+            return null;
+          }
+
+          await saveToRedis<CacheValue>(signerCacheKey, {
+            type: 'signer',
+            value: identity,
+          });
+          return identity;
+        }
+      } catch (error) {
+        console.error(`Failed to fetch identity for address ${address}:`, error);
+      }
+      return null;
+    })
+  );
+
+  const validSigners = signerResults.filter((s): s is BapIdentity => s !== null);
+  console.log('Successfully processed signers:', validSigners.length);
+
+  return {
+    signerIds: validSigners.map((s) => s.idKey),
+    signers: validSigners,
+  };
+}
+
+const ChannelParams = t.Object({
+  channelId: t.String(),
+});
+
 export const socialRoutes = new Elysia()
   .get(
     '/channels',
@@ -1010,7 +711,12 @@ export const socialRoutes = new Elysia()
         const validatedSigners: BapIdentity[] = signers.map((s) => ({
           ...s,
           identityTxId: s.identityTxId || '',
-          identity: typeof s.identity === 'string' ? s.identity : JSON.stringify(s.identity) || '',
+          identity:
+            typeof s.identity === 'string'
+              ? s.identity
+              : typeof s.identity === 'object'
+                ? s.identity
+                : JSON.stringify(s.identity || {}),
         }));
 
         const response: ChannelMessage = {
@@ -1122,8 +828,8 @@ export const socialRoutes = new Elysia()
       }
     },
     {
-      body: LikeRequest,
-      response: LikeResponse,
+      body: LikeRequestSchema,
+      response: LikeResponseSchema,
       detail: {
         tags: ['social'],
         description: 'Get likes for transactions or messages',
@@ -1291,7 +997,7 @@ export const socialRoutes = new Elysia()
     {
       params: t.Object({ bapId: t.String() }),
       query: MessageQuery,
-      response: DMResponse,
+      response: DMResponseSchema,
       detail: {
         tags: ['social'],
         description: 'Get encrypted direct messages for a BAP ID',
@@ -1336,7 +1042,7 @@ export const socialRoutes = new Elysia()
     {
       params: t.Object({ bapId: t.String(), targetBapId: t.String() }),
       query: MessageQuery,
-      response: DMResponse,
+      response: DMResponseSchema,
       detail: {
         tags: ['social'],
         description: 'Get encrypted direct messages between two BAP IDs',
@@ -1360,14 +1066,9 @@ export const socialRoutes = new Elysia()
     }
   )
   .ws('/@/:bapId/messages/:targetBapId/listen', {
-    body: t.Object({
-      params: t.Object({
-        bapId: t.String(),
-        targetBapId: t.String(),
-      }),
-    }),
-    open: async ({ data }) => {
-      const { bapId, targetBapId } = data.params;
+    body: MessageListenParams,
+    open: async (ws) => {
+      const { bapId, targetBapId } = ws.data.params;
       const identity = await fetchBapIdentityData(bapId);
       if (!identity?.currentAddress) {
         throw new Error('Invalid BAP identity');
@@ -1378,77 +1079,45 @@ export const socialRoutes = new Elysia()
         throw new Error('Invalid target BAP identity');
       }
       const targetAddress = targetIdentity.currentAddress;
-      const dbo = await getDbo();
-      const cursor = dbo.collection('message').watch([
-        {
-          $match: {
-            $or: [
-              {
-                $and: [
-                  { 'fullDocument.MAP.bapID': bapId },
-                  {
-                    $or: [
-                      { 'fullDocument.AIP.algorithm_signing_component': targetAddress },
-                      { 'fullDocument.AIP.address': targetAddress },
-                    ],
-                  },
-                ],
-              },
-              {
-                $and: [
-                  { 'fullDocument.MAP.bapID': targetBapId },
-                  {
-                    $or: [
-                      { 'fullDocument.AIP.algorithm_signing_component': bapAddress },
-                      { 'fullDocument.AIP.address': bapAddress },
-                    ],
-                  },
-                ],
-              },
-            ],
-          },
-        },
-      ]);
+
+      const cursor = await watchDirectMessages({
+        bapId,
+        bapAddress,
+        targetBapId,
+        targetAddress,
+      });
 
       cursor.on('change', (change: ChangeStreamInsertDocument<BmapTx>) => {
-        return change.fullDocument?._id;
+        ws.send(change.fullDocument?._id);
       });
     },
+    detail: messageListenEndpointDetail,
   })
   .ws('/@/:bapId/messages/listen', {
-    body: t.Object({
-      params: t.Object({
-        bapId: t.String(),
-      }),
-    }),
-    open: async ({ data }) => {
-      const { bapId } = data.params;
+    body: MessageListenParams,
+    open: async (ws) => {
+      const { bapId } = ws.data.params;
       const identity = await fetchBapIdentityData(bapId);
       if (!identity?.currentAddress) {
         throw new Error('Invalid BAP identity');
       }
       const bapAddress = identity.currentAddress;
-      const dbo = await getDbo();
-      const cursor = dbo.collection('message').watch([
-        {
-          $match: {
-            $or: [
-              { 'fullDocument.MAP.bapID': bapId },
-              { 'fullDocument.AIP.algorithm_signing_component': bapAddress },
-              { 'fullDocument.AIP.address': bapAddress },
-            ],
-          },
-        },
-      ]);
+
+      const cursor = await watchAllMessages({
+        bapId,
+        bapAddress,
+      });
+
       cursor.on('change', (change: ChangeStreamInsertDocument<BmapTx>) => {
-        return {
+        ws.send({
           tx: change.fullDocument?._id,
           bap_id: change.fullDocument?.MAP?.[0]?.bapID,
           algorithm_signing_component: change.fullDocument?.AIP?.[0]?.algorithm_signing_component,
           aip_address: change.fullDocument?.AIP?.[0]?.address,
-        };
+        });
       });
     },
+    detail: messageListenEndpointDetail,
   })
   .get(
     '/identities',
@@ -1508,7 +1177,9 @@ export const socialRoutes = new Elysia()
                     identity:
                       typeof identity.identity === 'string'
                         ? identity.identity
-                        : JSON.stringify(identity.identity || {}),
+                        : typeof identity.identity === 'object'
+                          ? identity.identity
+                          : JSON.stringify(identity.identity || {}),
                     identityTxId: identity.identityTxId || '',
                     block: typeof identity.block === 'number' ? identity.block : 0,
                     timestamp: typeof identity.timestamp === 'number' ? identity.timestamp : 0,
@@ -1524,14 +1195,20 @@ export const socialRoutes = new Elysia()
           })
         );
 
-        const filteredIdentities = identities.filter((id): id is Identity => {
+        const filteredIdentities = identities.filter((id): id is BapIdentity => {
           if (!id) return false;
           return (
             typeof id.idKey === 'string' &&
             typeof id.rootAddress === 'string' &&
             typeof id.currentAddress === 'string' &&
             Array.isArray(id.addresses) &&
-            typeof id.identity === 'string' &&
+            id.addresses.every(
+              (addr) =>
+                typeof addr.address === 'string' &&
+                typeof addr.txId === 'string' &&
+                (typeof addr.block === 'number' || addr.block === undefined)
+            ) &&
+            (typeof id.identity === 'string' || typeof id.identity === 'object') &&
             typeof id.identityTxId === 'string' &&
             typeof id.block === 'number' &&
             typeof id.timestamp === 'number' &&
@@ -1563,7 +1240,7 @@ export const socialRoutes = new Elysia()
       }
     },
     {
-      response: IdentityResponse,
+      response: IdentityResponseSchema,
       detail: {
         tags: ['identities'],
         description: 'Get all known BAP identities',
@@ -1586,100 +1263,3 @@ export const socialRoutes = new Elysia()
       },
     }
   );
-
-// Shared function for fetching messages
-async function getDirectMessages({
-  bapId,
-  targetBapId = null,
-  page = 1,
-  limit = 100,
-}: {
-  bapId: string;
-  targetBapId?: string | null;
-  page: number;
-  limit: number;
-}): Promise<DMResponse> {
-  const skip = (page - 1) * limit;
-
-  // Get current address for BAP ID
-  const identity = await fetchBapIdentityData(bapId);
-  if (!identity?.currentAddress) {
-    throw new Error('Invalid BAP identity');
-  }
-
-  // Add this block to fetch target identity
-  let targetIdentity: BapIdentity | null = null;
-  if (targetBapId) {
-    targetIdentity = await fetchBapIdentityData(targetBapId);
-    if (!targetIdentity?.currentAddress) {
-      throw new Error('Invalid target BAP identity');
-    }
-  }
-
-  const db = await getDbo();
-  const messageQuery = targetBapId
-    ? {
-        $and: [
-          { 'MAP.type': 'message' },
-          {
-            $or: [
-              {
-                'MAP.bapID': targetBapId,
-                'AIP.algorithm_signing_component': identity.currentAddress,
-              },
-              {
-                'MAP.bapID': bapId,
-                'AIP.algorithm_signing_component': targetIdentity.currentAddress,
-              },
-            ],
-          },
-        ],
-      }
-    : {
-        'MAP.type': 'message',
-        'MAP.bapID': bapId,
-      };
-
-  const col = db.collection('message');
-  const results = (await col
-    .find(messageQuery)
-    .sort({ 'blk.t': -1 })
-    .skip(skip)
-    .limit(limit)
-    .project({ _id: 0 })
-    .toArray()) as Message[];
-
-  const count = results.length;
-
-  let signers: BapIdentity[] = [];
-  const messagesWithAIP = results.filter((msg) => msg.AIP?.length);
-  if (messagesWithAIP.length) {
-    signers = await resolveSigners(messagesWithAIP);
-  }
-
-  return {
-    bapID: bapId,
-    page,
-    limit,
-    count,
-    results: results.map((msg) => ({
-      ...msg,
-      MAP: msg.MAP.map((m) => ({
-        ...m,
-        bapID: m.bapID || '',
-      })),
-      B: msg.B.map((b) => ({
-        encoding: b?.encoding || '',
-        Data: {
-          utf8: b.Data?.utf8 || '',
-          data: b.Data?.data || '',
-        },
-      })),
-    })),
-    signers: signers.map((s) => ({
-      ...s,
-      identityTxId: s.identityTxId || '',
-      identity: typeof s.identity === 'string' ? s.identity : JSON.stringify(s.identity) || '',
-    })),
-  };
-}
diff --git a/swagger/channels.ts b/social/swagger/channels.ts
similarity index 93%
rename from swagger/channels.ts
rename to social/swagger/channels.ts
index 9934364..11658b1 100644
--- a/swagger/channels.ts
+++ b/social/swagger/channels.ts
@@ -1,5 +1,14 @@
 import { t } from 'elysia';
 import type { OpenAPIV3 } from 'openapi-types';
+import type { ChannelMessage } from './messages.js';
+
+export interface ChannelInfo {
+  channel: string;
+  creator: string;
+  last_message: string;
+  last_message_time: number;
+  messages: number;
+}
 
 export const ChannelResponseSchema = t.Array(
   t.Object({
diff --git a/swagger/friend.ts b/social/swagger/friend.ts
similarity index 91%
rename from swagger/friend.ts
rename to social/swagger/friend.ts
index 931e6eb..8155d93 100644
--- a/swagger/friend.ts
+++ b/social/swagger/friend.ts
@@ -1,6 +1,26 @@
 import { t } from 'elysia';
 import type { OpenAPIV3 } from 'openapi-types';
 
+export interface RelationshipState {
+  fromMe: boolean;
+  fromThem: boolean;
+  mePublicKey?: string;
+  themPublicKey?: string;
+  unfriended: boolean;
+}
+
+export interface FriendshipResponse {
+  friends: Friend[];
+  incoming: string[];
+  outgoing: string[];
+}
+
+export interface Friend {
+  bapID: string;
+  themPublicKey: string;
+  mePublicKey: string;
+}
+
 export const FriendResponseSchema = t.Object({
   friends: t.Array(
     t.Object({
diff --git a/social/swagger/identity.ts b/social/swagger/identity.ts
new file mode 100644
index 0000000..98a3f28
--- /dev/null
+++ b/social/swagger/identity.ts
@@ -0,0 +1,148 @@
+import { t } from 'elysia';
+import type { OpenAPIV3 } from 'openapi-types';
+import type { BapIdentity } from '../../bap';
+
+export interface SigmaIdentityAPIResponse {
+  status: string;
+  result: SigmaIdentityResult;
+  error: string | null;
+}
+
+export interface SigmaIdentityResult {
+  idKey: string;
+  rootAddress: string;
+  currentAddress: string;
+  addresses: {
+    address: string;
+    txId: string;
+    block: number | undefined;
+  }[];
+  identity: string;
+  identityTxId: string;
+  block: number;
+  timestamp: number;
+  valid: boolean;
+}
+
+export interface Identity {
+  idKey: string;
+  rootAddress: string;
+  currentAddress: string;
+  addresses: {
+    address: string;
+    txId: string;
+    block: number | undefined;
+  }[];
+  identity: string;
+  identityTxId: string;
+  block: number;
+  timestamp: number;
+  valid: boolean;
+}
+
+export const IdentityResponseSchema = t.Array(
+  t.Object({
+    idKey: t.String(),
+    rootAddress: t.String(),
+    currentAddress: t.String(),
+    addresses: t.Array(
+      t.Object({
+        address: t.String(),
+        txId: t.String(),
+        block: t.Optional(t.Number()),
+      })
+    ),
+    identity: t.String(),
+    identityTxId: t.String(),
+    block: t.Number(),
+    timestamp: t.Number(),
+    valid: t.Boolean(),
+  })
+);
+
+export const identityEndpointDetail: OpenAPIV3.OperationObject = {
+  tags: ['social'],
+  description: 'Get list of all identities',
+  summary: 'List identities',
+  responses: {
+    '200': {
+      description: 'List of identities',
+      content: {
+        'application/json': {
+          schema: {
+            type: 'array' as const,
+            items: {
+              type: 'object' as const,
+              properties: {
+                idKey: {
+                  type: 'string' as const,
+                  description: 'Identity key',
+                },
+                rootAddress: {
+                  type: 'string' as const,
+                  description: 'Root address',
+                },
+                currentAddress: {
+                  type: 'string' as const,
+                  description: 'Current address',
+                },
+                addresses: {
+                  type: 'array' as const,
+                  items: {
+                    type: 'object' as const,
+                    properties: {
+                      address: {
+                        type: 'string' as const,
+                        description: 'Bitcoin address',
+                      },
+                      txId: {
+                        type: 'string' as const,
+                        description: 'Transaction ID',
+                      },
+                      block: {
+                        type: 'number' as const,
+                        description: 'Block number',
+                        nullable: true,
+                      },
+                    },
+                  },
+                },
+                identity: {
+                  type: 'string' as const,
+                  description: 'Identity data',
+                },
+                identityTxId: {
+                  type: 'string' as const,
+                  description: 'Identity transaction ID',
+                },
+                block: {
+                  type: 'number' as const,
+                  description: 'Block number',
+                },
+                timestamp: {
+                  type: 'number' as const,
+                  description: 'Timestamp',
+                },
+                valid: {
+                  type: 'boolean' as const,
+                  description: 'Validity flag',
+                },
+              },
+            },
+          },
+        },
+      },
+    },
+    '500': {
+      description: 'Internal Server Error',
+      content: {
+        'application/json': {
+          schema: {
+            type: 'array' as const,
+            items: {},
+          },
+        },
+      },
+    },
+  },
+};
diff --git a/social/swagger/likes.ts b/social/swagger/likes.ts
new file mode 100644
index 0000000..7cd601c
--- /dev/null
+++ b/social/swagger/likes.ts
@@ -0,0 +1,99 @@
+import { t } from 'elysia';
+import type { OpenAPIV3 } from 'openapi-types';
+import type { BapIdentity } from '../../bap.js';
+
+export interface Reactions {
+  channel: string;
+  page: number;
+  limit: number;
+  count: number;
+  results: Reaction[];
+}
+
+export interface Reaction {
+  tx: {
+    h: string;
+  };
+  blk: {
+    i: number;
+    t: number;
+  };
+  MAP: {
+    type: string;
+    tx?: string;
+    messageID?: string;
+    emoji?: string;
+  }[];
+  AIP?: {
+    algorithm_signing_component: string;
+  }[];
+}
+
+export interface LikeRequest {
+  txids?: string[];
+  messageIds?: string[];
+}
+
+export interface LikeResponse {
+  txid: string;
+  likes: Reaction[];
+  total: number;
+  signers: BapIdentity[]; // Full signer objects for API response
+}
+
+export const LikeRequestSchema = t.Object({
+  txids: t.Optional(t.Array(t.String())),
+  messageIds: t.Optional(t.Array(t.String())),
+});
+
+export const LikeResponseSchema = t.Array(
+  t.Object({
+    txid: t.String(),
+    likes: t.Array(
+      t.Object({
+        tx: t.Object({
+          h: t.String(),
+        }),
+        blk: t.Object({
+          i: t.Number(),
+          t: t.Number(),
+        }),
+        MAP: t.Array(
+          t.Object({
+            type: t.String(),
+            tx: t.Optional(t.String()),
+            messageID: t.Optional(t.String()),
+            emoji: t.Optional(t.String()),
+          })
+        ),
+        AIP: t.Optional(
+          t.Array(
+            t.Object({
+              algorithm_signing_component: t.String(),
+            })
+          )
+        ),
+      })
+    ),
+    total: t.Number(),
+    signers: t.Array(
+      t.Object({
+        idKey: t.String(),
+        rootAddress: t.String(),
+        currentAddress: t.String(),
+        addresses: t.Array(
+          t.Object({
+            address: t.String(),
+            txId: t.String(),
+            block: t.Optional(t.Number()),
+          })
+        ),
+        identity: t.String(),
+        identityTxId: t.String(),
+        block: t.Number(),
+        timestamp: t.Number(),
+        valid: t.Boolean(),
+      })
+    ),
+  })
+);
diff --git a/swagger/messages.ts b/social/swagger/messages.ts
similarity index 62%
rename from swagger/messages.ts
rename to social/swagger/messages.ts
index ab77671..44fc552 100644
--- a/swagger/messages.ts
+++ b/social/swagger/messages.ts
@@ -1,5 +1,45 @@
 import { t } from 'elysia';
 import type { OpenAPIV3 } from 'openapi-types';
+import type { BapIdentity } from '../../bap.js';
+
+export interface Message {
+  tx: {
+    h: string;
+  };
+  blk: {
+    i: number;
+    t: number;
+  };
+  MAP: {
+    app: string;
+    type: string;
+    paymail?: string;
+    context?: string;
+    channel?: string;
+    bapID?: string;
+  }[];
+  B: {
+    encoding: string;
+    Data: {
+      utf8: string;
+      data?: string;
+    };
+  }[];
+  AIP?: {
+    algorithm: string;
+    address: string;
+    algorithm_signing_component: string;
+  }[];
+}
+
+export interface ChannelMessage {
+  channel: string;
+  page: number;
+  limit: number;
+  count: number;
+  results: Message[];
+  signers: BapIdentity[];
+}
 
 export const MessageQuery = t.Object({
   page: t.Optional(t.String()),
@@ -24,8 +64,10 @@ export const ChannelMessageSchema = t.Object({
         t.Object({
           app: t.String(),
           type: t.String(),
-          channel: t.String(),
-          paymail: t.String(),
+          paymail: t.Optional(t.String()),
+          context: t.Optional(t.String()),
+          channel: t.Optional(t.String()),
+          bapID: t.Optional(t.String()),
         })
       ),
       B: t.Array(
@@ -40,8 +82,9 @@ export const ChannelMessageSchema = t.Object({
       AIP: t.Optional(
         t.Array(
           t.Object({
-            address: t.Optional(t.String()),
-            algorithm_signing_component: t.Optional(t.String()),
+            algorithm: t.String(),
+            address: t.String(),
+            algorithm_signing_component: t.String(),
           })
         )
       ),
@@ -198,3 +241,114 @@ export const channelMessagesEndpointDetail: OpenAPIV3.OperationObject = {
     },
   },
 };
+
+export const MessageListenParams = t.Object({
+  params: t.Object({
+    bapId: t.String(),
+    targetBapId: t.Optional(t.String()),
+  }),
+});
+
+export const messageListenEndpointDetail: OpenAPIV3.OperationObject = {
+  tags: ['social'],
+  description: 'Listen to real-time messages for a BAP ID',
+  parameters: [
+    {
+      name: 'bapId',
+      in: 'path',
+      required: true,
+      schema: { type: 'string' },
+      description: 'BAP Identity Key',
+    },
+    {
+      name: 'targetBapId',
+      in: 'path',
+      required: false,
+      schema: { type: 'string' },
+      description: 'Optional target BAP Identity Key for direct messages',
+    },
+  ],
+  responses: {
+    '101': {
+      description: 'WebSocket connection established',
+    },
+    '400': {
+      description: 'Invalid BAP identity',
+      content: {
+        'application/json': {
+          schema: {
+            type: 'object',
+            properties: {
+              error: { type: 'string' },
+            },
+          },
+        },
+      },
+    },
+  },
+};
+
+export const DMResponseSchema = t.Object({
+  bapID: t.String(),
+  page: t.Number(),
+  limit: t.Number(),
+  count: t.Number(),
+  results: t.Array(
+    t.Object({
+      timestamp: t.Number(),
+      tx: t.Object({
+        h: t.String(),
+      }),
+      blk: t.Object({
+        i: t.Number(),
+        t: t.Number(),
+      }),
+      MAP: t.Array(
+        t.Object({
+          app: t.String(),
+          type: t.String(),
+          bapID: t.String(),
+          encrypted: t.Optional(t.String()),
+          context: t.Literal('bapID'),
+        })
+      ),
+      B: t.Array(
+        t.Object({
+          Data: t.Object({
+            utf8: t.String(),
+            data: t.Optional(t.String()),
+          }),
+          encoding: t.String(),
+        })
+      ),
+      AIP: t.Optional(
+        t.Array(
+          t.Object({
+            algorithm: t.String(),
+            address: t.Optional(t.String()),
+            algorithm_signing_component: t.Optional(t.String()),
+          })
+        )
+      ),
+    })
+  ),
+  signers: t.Array(
+    t.Object({
+      idKey: t.String(),
+      rootAddress: t.String(),
+      currentAddress: t.String(),
+      addresses: t.Array(
+        t.Object({
+          address: t.String(),
+          txId: t.String(),
+          block: t.Optional(t.Number()),
+        })
+      ),
+      identity: t.String(),
+      identityTxId: t.String(),
+      block: t.Number(),
+      timestamp: t.Number(),
+      valid: t.Boolean(),
+    })
+  ),
+});
diff --git a/tests/social/channels.test.ts b/tests/social/channels.test.ts
index 70d7173..3b1af96 100644
--- a/tests/social/channels.test.ts
+++ b/tests/social/channels.test.ts
@@ -1,14 +1,15 @@
 import { beforeEach, describe, expect, mock, test } from 'bun:test';
-import { socialRoutes } from '../../social.js';
+import type { CacheValue } from '../../cache.js';
+import { socialRoutes } from '../../social/routes.js';
 
 // Mock Redis with in-memory store
-const mockCache = new Map();
+const mockCache = new Map<string, CacheValue>();
 mock.module('../../cache.js', () => ({
   readFromRedis: async (key: string) => mockCache.get(key),
-  saveToRedis: async (key: string, value: any) => mockCache.set(key, value),
+  saveToRedis: async (key: string, value: CacheValue) => mockCache.set(key, value),
   client: {
     get: async (key: string) => mockCache.get(key),
-    set: async (key: string, value: any) => mockCache.set(key, value),
+    set: async (key: string, value: CacheValue) => mockCache.set(key, value),
     isReady: true,
   },
 }));
